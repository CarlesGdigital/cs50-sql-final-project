# Design Document

By Carles Gregori Grau

Video overview: <https://youtu.be/AXeSFTyFSzw>


## Scope

The purpose of this database is to provide a unified data model for managing rental properties and their operational lifecycle.

It centralizes information about apartments, tenants, rental contracts, maintenance incidents, external professionals, and the financial transactions associated with both rent collection and incident-related costs.

The goal is to give a property owner or property manager a single source of truth from which they can monitor which apartments are rented, to whom, under which conditions, and with what financial and maintenance impact over time.

Within the scope of the database are all core entities involved in day-to-day rental and maintenance management.

These include apartments (pisos) and their basic characteristics; tenants (inquilinos) and their contact and identification data; rental contracts and the relationship between contracts and one or more tenants; maintenance incidents linked to a specific apartment and service; the catalog of services that can be requested; external professionals and the services they can provide; the assignment of professionals to incidents; financial transactions that record rent payments and incident-related charges; and attachments that reference additional documentation related to incidents. Together, these entities allow the system to represent who lives where, under which contract, which issues have been reported, who is responsible for solving them, and how much money is being paid or spent in each case.

Outside the scope of this project are higher-level application concerns and advanced business processes that are not strictly required for modelling the core rental and maintenance domain. The database does not implement user authentication, authorization, or role management; it assumes that any access control would be handled by an external application layer.

It also does not attempt to replace a full accounting system or tax engine: while it stores individual transactions, it does not compute taxes, generate legal invoices, or produce official accounting reports. Communication workflows between tenants, owners, and professionals (such as messaging, notifications, or scheduling logic) are not represented beyond the data needed to record assignments and dates. Finally, the system does not handle property marketing or listing on external platforms; it focuses solely on managing properties once they are already part of the rental portfolio.


## Functional Requirements

This database is designed to allow a user, such as a property owner or property manager, to manage the core information related to a portfolio of rental apartments and their maintenance. First, a user should be able to register and look up all apartments (pisos), together with their basic characteristics such as address, city, area, surface in square meters, and zone. On top of these apartments, the user should be able to create rental contracts, specifying rent, deposit, start and end dates, and the current status of each contract, as well as link each contract to one or more tenants through an explicit relationship. The system should also support the management of tenants themselves, including their identification data, contact information, date of registration, and whether they are currently active or inactive.

Second, a user should be able to record and track maintenance incidents associated with a specific apartment and a particular type of service (for example plumbing, electricity, cleaning, and so on). For each incident, the database should store its status, severity, origin, description, creation date, and closing date, together with references to external attachments that provide additional documentation. The database should also allow the definition of a catalog of services and a list of external professionals, indicating for which services each professional is available, their priority, hourly cost, and average rating. Based on this information, the user should be able to register assignments of professionals to specific incidents, including the date on which the assignment was made, the scheduled date for the intervention, and the current status of the assignment.

Third, a user should be able to record financial transactions related to rental contracts (for example rent payments), to incidents (for example payments to professionals), or, when appropriate, directly to a specific apartment. Each transaction should include a date, amount, concept, bank, and a single link to exactly one contract, apartment, or incident. From these transactions, the database should support aggregate queries that answer common business questions, such as the total cost accumulated per incident, the total paid by each tenant, the profitability of each apartment, or the balance between rental income and maintenance expenses. The views and queries defined on top of the database are intended to make this type of analysis straightforward, without requiring additional business logic in the application layer.

Beyond these operations, there are actions that are deliberately outside the scope of what a user can do directly with this database. The system is not intended to manage access control, user permissions, or roles; any authentication or authorization is assumed to be handled by an external application. It is also not designed to execute complete business workflows, such as contract negotiation, automatic scheduling, or sending notifications and reminders to tenants or professionals. Likewise, the database does not implement a full accounting system: while it stores individual transactions and supports basic totals and balances, it does not generate legal invoices, compute taxes, or produce official accounting reports. Finally, the database does not include functionality for marketing or publishing apartments on external platforms; its focus is on internal management of rentals and incidents once properties are already part of the portfolio.





### Entities

The data model is built around a set of core entities that reflect the main concepts involved in managing rental apartments, tenants, contracts, incidents, professionals, and financial flows. For each entity, the schema uses integer primary keys to provide stable identifiers, and text fields for human-readable attributes such as names, descriptions, and addresses. Constraints such as `NOT NULL`, `CHECK`, and foreign keys are used to encode business rules directly in the database and to prevent inconsistent states.

#### Apartments (`pisos`)

The `pisos` table represents each apartment in the portfolio. It has an integer primary key `id` and several descriptive attributes: `direccion`, `ciudad`, `provincia`, `cp`, `superficie_m2`, and `zona`. All of these are stored as `TEXT`, since they are primarily human-readable labels rather than values we need to aggregate numerically. For example, `superficie_m2` could be stored as a number, but using text allows more flexibility (e.g. approximate values or units) without affecting the main analytical queries, which focus on financial data. There are no additional `CHECK` constraints on this table, because most of the validation for addresses would typically be handled at the application level.

#### Tenants (`inquilinos`)

The `inquilinos` table captures information about tenants. It uses an integer primary key `id` and includes `nombre`, `apellidos`, `identificacion`, `telefono`, and `email` as text attributes. The `email` column has a `CHECK (email LIKE '%@%')` constraint to enforce a minimal email format, preventing obviously invalid values from being stored. The `fecha_alta` column is stored as `TEXT`, but the intent is that it contains dates in a format compatible with SQLite’s `date` functions. The `estado` column is a `TEXT` field constrained to `('ACTIVO', 'INACTIVO')`, which makes it easy to filter current tenants and ensures that only valid status values are used.

#### Contracts (`contratos`) and contract–tenant relationship (`contratos_inquilinos`)

Rental contracts are represented by the `contratos` table. Each contract has an integer primary key `id`, a required foreign key `piso_id` pointing to the apartment being rented, and several attributes describing financial and temporal aspects: `renta`, `fianza`, `periodicidad`, `fecha_inicio`, `fecha_fin`, and `estado`. The `renta` and `fianza` columns are stored as `INTEGER` to support arithmetic operations when analysing income and guarantees. The `fecha_inicio` and `fecha_fin` columns are stored as `TEXT`, but protected by `CHECK` constraints that enforce valid date ordering: `fecha_inicio` must be on or after `1960-01-01`, and `fecha_fin` must be either `NULL` or strictly later than `fecha_inicio`. The `estado` column is constrained to `('ACTIVO', 'INACTIVO')` to distinguish current contracts from historical ones.

Because a contract may involve one or more tenants, the many-to-many relationship between contracts and tenants is modelled explicitly via the `contratos_inquilinos` table. This table has no surrogate key; instead, it uses the composite primary key `(contrato_id, inquilino_id)` to guarantee that the same tenant is not linked twice to the same contract. Optional attribute `rol` allows the database to distinguish different roles within the contract (for example, main tenant versus co-tenant) without enforcing a fixed list of roles. Both columns have foreign key constraints referencing `contratos` and `inquilinos` respectively, and `ON DELETE CASCADE` is used so that removing a contract or tenant automatically removes the corresponding links.

#### Services (`servicios`) and professionals (`profesionales`)

The `servicios` table stores the catalog of maintenance services that can be requested, such as plumbing or electricity. It uses an integer primary key `id`, a `servicio` column that is `TEXT NOT NULL UNIQUE` to avoid duplicate service names, and an optional `descripcion` column for a more detailed explanation of the service.

The `profesionales` table represents external professionals or companies that can perform those services. It has an integer primary key `id` and several text attributes: `nombre`, `apellidos`, `empresa`, `telefono`, `email`, `zona`, and `activo`. As with tenants, the `email` column has a `CHECK (email LIKE '%@%')` constraint for basic validation, and `activo` is constrained to `('ACTIVO', 'INACTIVO')` so that inactive professionals can be excluded from new assignments without removing their historical data.

Because a professional can offer multiple services and each service can be provided by multiple professionals, their relationship is modelled by the `profesionales_servicios` table. This table uses the composite primary key `(profesional_id, servicio_id)` and includes additional attributes that characterise the relationship: `prioridad`, `rating`, and `coste_hora`. The `rating` column is constrained to a numeric range between 1 and 5 (representing typical rating scales), and `coste_hora` is an `INTEGER` with a `CHECK (coste_hora >= 0)` to prevent negative hourly rates. Foreign key constraints to `profesionales` and `servicios` preserve referential integrity between the catalog and the professionals’ profiles.

#### Incidents (`incidencias`), assignments (`asignaciones`), and attachments (`adjuntos`)

Maintenance incidents are represented by the `incidencias` table. Each incident has an integer primary key `id` and foreign keys `piso_id`, `contrato_id` (optional), and `servicio_id` to link it to a specific apartment, an optional rental contract, and a type of service. The `estado` column is constrained to a fixed set of values (`'abierta', 'asignada', 'en_progreso', 'resuelta', 'cancelada'`), modelling the lifecycle of an incident. Additional attributes such as `gravedad`, `origen`, `descripcion`, `creado_en`, and `cerrado_en` are stored as `TEXT`; dates are again stored in a format compatible with SQLite date functions. Requiring `creado_en` to be `NOT NULL` ensures that every incident has a creation timestamp.

The `asignaciones` table models the assignment of a professional to a specific incident. It has an integer primary key `id`, optional foreign keys `profesional_id` and `incidencia_id`, and several attributes to track the progress and cost of the assignment: `asignado_en`, `programado_para`, `estado`, `coste_estimado`, and `coste_final`. The `asignado_en` column is `TEXT NOT NULL` with a `CHECK (date(asignado_en) IS NOT NULL)` to ensure that it is a valid date, and `estado` is constrained to `('En proceso', 'finalizado')` so that assignments can only be in clearly defined states. Foreign keys to `profesionales` and `incidencias` use `ON DELETE CASCADE` to keep the assignment data consistent when incidents or professionals are removed.

The `adjuntos` table stores references to external files linked to incidents. It has an integer primary key `id`, an optional foreign key `incidencia_id`, and text attributes `tipo`, `subido_en`, and `ruta`. The `ruta` column is `TEXT NOT NULL` and is used to store the path or URL to the actual file; the file itself is not stored in the database. The foreign key on `incidencia_id` also uses `ON DELETE CASCADE`, so that all attachments for an incident are removed automatically if the incident is deleted.

#### Transactions (`transacciones`)

The `transacciones` table records all financial movements related to contracts, apartments, and incidents. Each transaction has an integer primary key `id`, a `fecha` column (stored as `TEXT` and constrained so that `date(fecha) >= '1960-01-01'`), an `importe` stored as `INTEGER NOT NULL`, and descriptive attributes `explicacion`, `concepto`, `banco`, and `tipo`. What distinguishes this table is the way it links to the rest of the model: it contains three optional foreign keys, `contrato_id`, `piso_id`, and `incidencia_id`, and a `CHECK` constraint that enforces that exactly one of them must be non-NULL. This guarantees that every transaction is associated with one and only one logical context (a contract, a specific apartment, or a maintenance incident), while keeping all transactions in a single table for easier analysis. Foreign key constraints link these columns to `contratos`, `pisos`, and `incidencias`, ensuring that no transaction can reference a non-existent entity.

Overall, these entities and their attributes are chosen to reflect the core concepts of rental and maintenance management while keeping the schema relatively compact. Integer primary keys provide efficient joins, text columns offer flexibility for human-readable data, and `CHECK` and foreign key constraints encode key business rules directly in the database, reducing the risk of inconsistent or invalid states.


### Relationships

![Entity relationship diagram](<Final Project cs50 Harvard - Carles Gregori.png>)
## Optimizations

The schema includes several optimizations aimed at making the most common analytical queries easier to express and more efficient to execute. At the logical level, the design already uses integer primary keys for all main entities and composite primary keys for many-to-many relationship tables such as `profesionales_servicios` and `contratos_inquilinos`. These primary keys implicitly create indexes that speed up joins on identifiers and enforce uniqueness constraints, preventing duplicate relationships from being stored.

On top of the base tables, the database defines a set of views that encapsulate frequently used aggregations and joins. The `consulta_incidencias` view combines incidents, services, and related transactions to expose, for each incident, its state, severity, origin, service type, and the total financial amount associated with it. The `rentabilidad_piso` view aggregates transactions by contract and apartment to show, for each property, the total income recorded through contracts. The `inquilinos_info` view joins tenants, their contracts, and the corresponding transactions to provide, for each tenant, a summary of how much has been paid under each contract. Finally, the `balance_piso` view brings together rental income and incident expenses per apartment, computing both the totals for each category and an overall balance. These views are intended to centralize complex logic so that reporting queries can be written against a simpler, higher-level interface.

To support these views and typical access patterns, the schema also defines explicit indexes on foreign key columns that are used heavily in joins and filters. For example, the `transacciones_idx` index on `transacciones(incidencia_id)` improves the performance of queries that look up or aggregate transactions by incident, which is a common operation when analysing maintenance costs. The `inquilinos_ci_idx` index on `contratos_inquilinos(inquilino_id)` and the `inquilinos_t_idx` index on `transacciones(contrato_id)` speed up queries that start from a tenant and need to traverse their contracts and payments. Together with the primary-key and foreign-key indexes provided by the database engine, these additional indexes are chosen to support the main reporting queries without overcomplicating the schema or incurring unnecessary write overhead.

## Limitations

This design deliberately focuses on modelling the core concepts of rental and maintenance management for a single portfolio of apartments, and it makes several simplifying assumptions that limit what the database can represent. First, the schema assumes that all monetary amounts can be stored as integers in a single implicit currency. As a result, it does not handle multi-currency scenarios, decimal precision for cents, or more complex financial instruments. The `transacciones` table also enforces that each transaction must be linked to exactly one contract, apartment, or incident, which means that it cannot directly represent a single payment that covers multiple contracts or incidents at once; such cases would need to be split into multiple rows.

Second, temporal information is stored using `TEXT` columns that are intended to contain ISO-style dates. While this works well with SQLite’s built-in date functions, it does not capture time-of-day information or time zones, and it relies on the application layer to always provide correctly formatted values. The schema does not attempt to model historical versions of entities or keep a detailed audit trail: when the state of a tenant, contract, or professional changes (for example from active to inactive), only the current state is stored. This makes it difficult to reconstruct the full history of changes or to answer questions that depend on past states at specific points in time.

Third, the model simplifies several real-world aspects of property and maintenance management. For instance, apartments are represented with a small set of textual attributes and do not capture richer structural details (such as number of rooms or building-level information), and attachments only store a path to external files rather than the documents themselves. The database also does not represent higher-level workflow concepts such as negotiation stages, partial approvals, or detailed scheduling constraints beyond a few date fields. Finally, the design targets a single owner or management context; it does not distinguish between different owners, portfolios, or companies, and it does not include any notion of user accounts or permissions. These choices keep the schema compact and focused, but they also mean that the database is not well suited for scenarios that require fine-grained multi-tenant access control, complex accounting, or highly detailed operational workflows.
